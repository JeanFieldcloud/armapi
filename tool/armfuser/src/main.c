/***********************************************************************

 Copyright (c) 2016 ATIM
 
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 
 
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.

***********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <sys/stat.h>
#include <stdbool.h>
#include <sys/types.h>
#include <regex.h>
#include "entity.h"

extern int yyparse();
extern void yylex();
extern FILE *yyin;

#define SIZE_FILE_NAME 64
#define HERDER_FILE "// ---------------------------------------------------------------------\n"	\
					"// This file is generated by armfuser from the c source file.\n"				\
					"// Please do not edit this file.\n"											\
					"// Generation date: " __DATE__ " \n"											\
					"// ---------------------------------------------------------------------\n\n"
					
#define LICENCE		 "/***********************************************************************\n"		\
					"\n"																				\
					" Copyright (c) 2016 ATIM\n"														\
                    " \n"																				\
                    " \n"																				\
					" Permission is hereby granted, free of charge, to any person obtaining a copy\n"	\
					" of this software and associated documentation files (the \"Software\"), to deal\n"\
					" in the Software without restriction, including without limitation the rights\n"	\
					" to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"		\
					" copies of the Software, and to permit persons to whom the Software is\n"			\
					" furnished to do so, subject to the following conditions:\n"						\
                    " \n"																				\
                    " \n"																				\
					" The above copyright notice and this permission notice shall be included in\n"		\
					" all copies or substantial portions of the Software.\n"							\
                    " \n"																				\
                    " \n"																				\
					" THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"	\
					" IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"		\
					" FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n"	\
					" AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"			\
					" LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"	\
					" OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n"		\
					" THE SOFTWARE.\n"																	\
                    "\n"																				\
					"***********************************************************************/\n\n"		\

entity_t* makeTreeFromFile(char* fileName);
void cFileNameToCppFileName(char* fileName);

//Arm port
void writeHeaderArmPortClass(entity_t* treeHeader, entity_t* treeSource, int fd);

//Arm
void writeHeaderArmClass(entity_t* treeHeader, entity_t* treeSource, int fd);
void writeSourceArmClass(entity_t* treeHeader, entity_t* treeSource, int fd);

int main(int argc, char *argv[])
{
	//c file name
	char headerFileArmPort[SIZE_FILE_NAME] = "../../bindings/c/armport.h";
	char headerFileArm[SIZE_FILE_NAME] = "../../bindings/c/arm.h";
	char sourceFileArm[SIZE_FILE_NAME] = "../../bindings/c/arm.c";
	
	//Create tree from file
	entity_t* treeHeaderArmPort = makeTreeFromFile(headerFileArmPort);
	entity_t* treeHeaderArm = makeTreeFromFile(headerFileArm);
	entity_t* treeSourceArm = makeTreeFromFile(sourceFileArm);
	
	//convert c file name to cpp file name
	cFileNameToCppFileName(headerFileArmPort);
	cFileNameToCppFileName(headerFileArm);
	cFileNameToCppFileName(sourceFileArm);
	
	int fdHeaderArmPort = 	open(headerFileArmPort, O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
	int fdHeaderArm = 		open(headerFileArm, 	O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
	int fdSourceArm = 		open(sourceFileArm, 	O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
	
	//Write files
	writeHeaderArmPortClass(treeHeaderArmPort, NULL, fdHeaderArmPort);
	printf("File:\"%s\" -> Wrote!\n", headerFileArmPort);
	writeHeaderArmClass(treeHeaderArm, treeSourceArm, fdHeaderArm);
	printf("File:\"%s\" -> Wrote!\n", headerFileArm);
	writeSourceArmClass(treeHeaderArm, treeSourceArm, fdSourceArm);
	printf("File:\"%s\" -> Wrote!\n", sourceFileArm);
	
	close(fdHeaderArmPort);
	close(fdHeaderArm);
	close(fdSourceArm);
	
	
	return EXIT_SUCCESS;
}

entity_t* makeTreeFromFile(char* fileName)
{
	//Open and parse file
	yyin = fopen(fileName, "r");
	int errParse = yyparse();
	fclose(yyin);
	
	if(errParse)
	{
		printf("In file:\"%s\" -> Parse fail!\n", fileName);
		return NULL;
	}
	
	printf("In file:\"%s\" -> Parse success!\n", fileName);
	
	entity_t* entRoot = entGetRoot();
	entSetRoot(NULL);
	
	return entRoot;
}

void cFileNameToCppFileName(char* fileName)
{
	char* ptrstr;
	char bufstr[SIZE_FILE_NAME];
	
	//If source file ?
	if(strstr(fileName, ".c"))
		strcat(fileName, "pp");
	
	ptrstr = strstr(fileName, "/c/");
	strcpy(bufstr, ptrstr+3);
	*ptrstr='\0';
	strcat(fileName, "/cpp/");
	strcat(fileName, bufstr);
}

void writeHeaderArmPortClass(entity_t* treeHeader, entity_t* treeSource, int fd)
{
	entity_t* ent = treeHeader;
	bool inClassPublic = false;
	bool inClassStop = false;
	
	//Write header
	dprintf(fd, HERDER_FILE);
	dprintf(fd, LICENCE);
	while(ent)
	{
		if(ent->nextEntity == NULL)
		{
			inClassPublic = false;
			inClassStop = true;
		}
		
		//Start to write class, write public functions
		if(	inClassPublic ||
			ent->type == ENT_FUN_PROTO_ARM_PORT			||
			ent->type == ENT_FUN_STATIC_PROTO_ARM_PORT)
		{
			if(!inClassPublic)
			{
				dprintf(fd, "\nclass ArmPort\n");
				dprintf(fd, "{\n");
				dprintf(fd, "\tpublic:\n");
				dprintf(fd, "\t\tArmPort();\n");
				dprintf(fd, "\t\t~ArmPort();\n\n\t\t");
				
				inClassPublic = true;
			}
			else
			{
				dprintf(fd, "\t\t");
			}
		}
		else if(inClassStop)//write end class
		{	
			//Write private attributes
			dprintf(fd, "\n\tprivate:\n");
			dprintf(fd, "\tvoid* _port;\n");
			dprintf(fd, "};\n\n");
			
			inClassStop = false;
			inClassPublic = false;
		}
		
		if(ent->type == ENT_DOC)
			ent->type = ENT_DOC_ARM_PORT;
			
		entCToCpp(ent);
		entWrite(fd, ent);
		ent = ent->nextEntity;
	}
}

void writeHeaderArmClass(entity_t* treeHeader, entity_t* treeSource, int fd)
{
	entity_t* ent = treeHeader;
	bool inClassPublic = false;
	bool inClassStop = false;
	entity_t* entArmStruc = NULL;
	
	//Write header
	dprintf(fd, HERDER_FILE);
	dprintf(fd, LICENCE);
	while(ent)
	{
		if(ent->nextEntity == NULL)
		{
			inClassPublic = false;
			inClassStop = true;
		}
			
		if(ent->type == ENT_STRUCT)
		{
			//Is arm_t structure ?
			if(strstr(ent->str, "}arm_t;"))
			{
				entArmStruc = ent;
				ent = ent->nextEntity;
				continue;
			}
		}
		
		//Start to write class, write public functions
		if(	inClassPublic ||
			ent->type == ENT_FUN_PROTO_ARM			||
			ent->type == ENT_FUN_STATIC_PROTO_ARM)
		{
			if(!inClassPublic)
			{
				//dprintf(fd, "class ArmPort;\n");
				dprintf(fd, "class Arm\n");
				dprintf(fd, "{\n");
				dprintf(fd, "\tpublic:\n");
				dprintf(fd, "\t\tArm();\n");
				dprintf(fd, "\t\t~Arm();\n\n\t\t");
				
				inClassPublic = true;
			}
			else
			{
				dprintf(fd, "\t\t");
			}
		}
		else if(inClassStop)//write end class
		{
			//write private functions from source file
			dprintf(fd, "\n\tprivate:\n");
			entity_t* ent = treeSource;
			while(ent)
			{
				if(	ent->type == ENT__FUN_PROTO_ARM			||
					ent->type == ENT__FUN_STATIC_PROTO_ARM)
				{
					entCToCpp(ent);
					dprintf(fd, "\t\t");
					entWrite(fd, ent);
				}
				
				ent = ent->nextEntity;
			}
			
			//Write private attributes
			dprintf(fd, "\n\tArmPort\t_port;\n");
			
			//Extract attributes from arm_t structure
			char cstr[4*1024];
			strcpy(cstr, entArmStruc->str);
			strRepExp(cstr, "[^\n]+\n", "");
			strRepExp(cstr, "[^\n]+\n", "");
			strRepExp(cstr, "[^\n]+\n", "");
			strRepExp(cstr, "[^\n]+_port[^\n]\n", "");
			strRepExp(cstr, "}arm_t;", "");
			
			dprintf(fd, "%s", cstr);
			
			//End to write class
			dprintf(fd, "};\n\n");
			
			inClassStop = false;
			inClassPublic = false;
		}
		
		if(ent->type == ENT_DOC)
			ent->type = ENT_DOC_ARM;
			
		entCToCpp(ent);
		entWrite(fd, ent);
		ent = ent->nextEntity;
	}
}

void writeSourceArmClass(entity_t* treeHeader, entity_t* treeSource, int fd)
{
	bool writConstructor = false;
	entity_t* ent = treeSource;
	
	//Write header
	dprintf(fd, HERDER_FILE);
	dprintf(fd, LICENCE);
	while(ent)
	{	
		if(	ent->type == ENT__FUN_PROTO_ARM ||
			ent->type == ENT__FUN_STATIC_PROTO_ARM)
		{
			ent = ent->nextEntity;
			continue;
		}
		
		if(	!writConstructor &&
			(ent->type == ENT_FUNCTION))
		{
			dprintf(fd, "Arm::Arm()\n");
			dprintf(fd, "{\n");
			dprintf(fd, "}\n\n");

			dprintf(fd, "Arm::~Arm()\n");
			dprintf(fd, "{\n");
			dprintf(fd, "}\n\n");
			
			writConstructor = true;
		}
		
		if(ent->type == ENT_DOC)
			ent->type = ENT_DOC_ARM;
			
		entCToCpp(ent);
		entWrite(fd, ent);
		ent = ent->nextEntity;
	}
}
